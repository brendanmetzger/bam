<article id="third-coast">
  <header>
    <h2>Third Coast</h2>
    <h4>
      <time>2016</time>
    </h4>
    <h4>
      <a href="http://thirdcoastfestival.org">thirdcoastfestival.org</a>
    </h4>
    <p>The Third Coast International Audio Festival is an organization beloved by audio-storytelling enthusiasts long before podcasts were a thing.</p>
  </header>
  <section>
    <h3>
      <strong>Design to Size of Client</strong>
    </h3>
    <p>Third Coast had an archive of audio bundled into a substantial Rails application. They have (still do) a labyrinthian  array of audio based content that lives under different contexts and categories. To <em>limit</em> duplication, the relational database had 40+ tables sized over a 1<abbr title="gigabyte">gb</abbr> and the necessary application code spanned hundreds of application files.</p>
    <p>Concerning a gigabyte, perspective helps: the <a href="http://www.greennet.org.uk/support/understanding-file-sizes">1911 edition of <cite>Encyclopaedia Britannica</cite> is 25<abbr title="megabytes">mb</abbr></a>. Based on that, a liberal estimate may argue that a 40-table database contains no more than one encyclopedia&#x2019;s worth of substantive content. This means <mark>the Rails database was ~98% metadata.</mark> Needless to say, a large conceptual knot to loosen.</p>
  </section>
  <section>
    <h3>
      <strong>Honor the Knot</strong>
    </h3>
    <p>All developers start a project with some kind of agenda. Unfortunately, that agenda often dictates the tool or program that will regulate the construction of content which unravels as the framework is tailored to fit the shape of the organization. In this project there was a dizzying array of joins between tables and the very same information modeled and remodeled and re-remodeled. This can be avoided with a graph, and I designed and implemented an application that stored relationships in an <abbr title="extensible markup language">xml</abbr> document. While <abbr title="extensible markup language">xml</abbr> may seem antiquarian, it makes defining object-oriented relationships pretty easy.</p>
    <p>This scheme required that all content is structurally identical, meaning the <em>exact same</em> form can be used to describe a person or a story. Each small item is assigned to a model, the application ascribes rules for joining models into relationships, which then model bigger, more complicated ideas. It is perfectly possible to plan an efficient relational database, but the advantage here is one can get started before the entire agenda is ironed out. Projects inevitably evolve and change direction; if extra development resources are available, those resources can be used to evolve and maintain schema. If resources are a bit more precious (which is generally the case in my experience), a graphed dataset is purposefully abstract; changing ideas only requires changing the application code, not how data is stored or accumulates.</p>
    <p>Pontificating aside, this <abbr title="extensible markup language">xml</abbr> data document is 2<abbr title="megabyte">mb</abbr>. That is <mark>&#xBD; of 1% of the original size,</mark> or for comparison, the largest ship ever and a tuna fish. More importantly, a robust network was established to organize and navigate content that feels more like a corn maze than a corn field.</p>
    <figure>
      <figcaption>
        <video src="http://static.brendanmetzger.com.s3.amazonaws.com/videos/third-coast.m4v" loop="loop" controls="controls" preload="metadata">
          <p>html5 video</p>
        </video>
        <p>This is a bit dizzying, so consider reading this before watching. There were some key aspects that needed to happen: first, the audio never stops (<a href="#sound-opinions">I cut my teeth on this with Sound Opinions</a>). Second, I wanted it to never stop, not even while editing. Third, I'm tired of 'backend' systems&#x2014;it's just twice as much work to maintain.</p>
        <p>With no backend, to edit anything, you find it on the site (or search it directly) and then find an edit button to click. Recall, each node is small and well-connected; to edit a person, I don't have to be on that persons page, I can be viewing anything they are connected to and edit them there. For example, in the video I can remove a person as a producer of a story by editing that person. Then I can add the same person as a producer to a story from the story page itself. Sound like the same thing in reverse? It actually is, which is why this application has less lines of code than a notable JavaScript framework that has the sole function of embedding other JavaScript frameworks.</p>
      </figcaption>
    </figure>
  </section>
</article>